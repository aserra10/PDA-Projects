---
title: "Logistic Mixed-Effects Prediction Models for Tracheostomy in Infants with Severe Bronchopulmonary Dysplasia"
subtitle: 'Alitzel Serrano Laguna'
format: pdf
editor: visual
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE)
```

```{r}
#Load Needed Libraries
library(mice)
library(naniar)
library(tidyverse)
library(gtsummary)
library(gridExtra)
library(tableone)
library(lme4)
library(ggplot2)
library(glmnet)
require(lattice)
require(pan)
library(tableone)
library(leaps)
library(knitr)
library(kableExtra)
library(pROC)
```

```{r}
###################
#Data Pre-processing
trach_data <- read.csv("~/Project2/project2.csv")
###################

#delete duplicate ids
#which(trach_data$record_id == 2000824)
trach_data <- trach_data[-c(790,791,792),]
#change numeric to factors
trach_data[,c(2:4,9:15,17,21,23,27, 29:30)] <- lapply(trach_data[,c(2:4,9:15,17,21,23,27,29:30)], factor)

#Create severity of BPD variable indicator at week 36 
trach_data <- trach_data %>% mutate(severity.36 = case_when(
  (ventilation_support_level.36 == 0 | 
     (ventilation_support_level.36 == 1  & inspired_oxygen.36 < 0.22)) ~ 'mild', 
  ((ventilation_support_level.36 == 2 & inspired_oxygen.36 <= 0.21) | 
     (ventilation_support_level.36 == 1 & inspired_oxygen.36 < 0.30 & inspired_oxygen.36 >= 0.22)) ~ 'moderate',
   ((ventilation_support_level.36 == 2 & inspired_oxygen.36 > 0.21) |
      (ventilation_support_level.36 == 1 & inspired_oxygen.36 >= 0.30)) ~ 'severe'))

# which(is.na(trach_data$severity))
# sum(is.na(trach_data$severity))
# trach_data %>% group_by(severity, Trach) %>% summarize(n())
```

```{r}
#Explore Missingness by variable
miss_var <- as.data.frame(miss_var_summary(trach_data)) 
miss_var$pct_miss <- round(miss_var$pct_miss, 2)
#miss_var
Tab1 <- miss_var[miss_var$pct_miss > 10,] %>% knitr::kable(caption = "Summary of Missing Data by Variable",
                                                    col.names = c("Variable",  "Count",
                                                                  "Percentage")) %>%
  kable_styling(latex_options = c("striped"),
                             stripe_color = "gray!15")
Tab1

```

## Abstract

This paper conducts a thorough examination of five tracheostomy outcome prediction models, employing four different fitting methods to select the most effective model. Models undergo evaluation using positive and negative predictive value comparison, accuracy, AUC measure, and coefficient estimates. The results showed that the lasso model with two-way interactions consistently outperforms its counterparts, demonstrating better predictive accuracy compared to all other fitting models.

## Study setting and population characteristics

Data was gathered from centers in the U.S. participating in the BPD Collaborative Registry which contains multicenter interdisciplinary BPD programs located in the United States and Sweden. The dataset includes baseline and demographic characteristics in addition to respiratory support information at 36 and 44 weeks PMA for infants born at or earlier than 32 weeks PMA who are at higher risk for BPD. Severity of BPD categories (Mild, Moderate, Severe) at week 36 PMA were coded using the NHLBI(2018) definition.

Table 1 summarizes missing data for covariates with greater than 10% missingness. From this table, it is observed that respiratory covariate measures at week 44 have more than 40% missingness. Additionally, Table 2 summarizes the mean percentage of missing data for participants with greater than 30% missing data, grouped by center and trach outcome. Only centers 1,2,4,7,and 12 had at least 7 participants with more than 30% missing data. We also observe that one infant is missing data from which center they received care. Infants who received a tracheostomy also tended to have a larger percentage of missing data.

Table 3 summarizes the overall population characteristics and also stratifies by tracheostomy outcome. The dataset includes a total of 996 infants, 58.9% being male, 14.7% receiving a tracheostomy, and 5.4% having died. This data was collected across ten different centers. In stratifying by tracheostomy outcome, we observe n = 146 infants had a tracheostomy. There are also statistically significant differences between infants who had and did not have a tracheostomy. Infants who received a tracheostomy, had a significantly lower mean weight at birth and 36 weeks but not at 44 weeks compared to infants who did not receive a tracheostomy. Infants who received a tracheostomy also had higher values for fraction of inspired oxygen, peak inspiratory pressure(cmH2O), and positive and exploratory pressure (cm H2O) at weeks 36 and 44. Their mean gestational age of hospital discharge is 79.94 compared to 48.92 for infants who did not receive a tracheostomy.

Moreover, we observe differences across centers, with centers 1, 2, and 12 having the highest number of infants who received a tracheostomy. Additionally from Table 3, we observed differences among infants who did and did not receive a tracheostomy for ventilation support and pulmonary hypertension at both weeks 36 and 44. In Table 4, stratified by centers, we observe that center 21 only has one individual (removed from the table due to NA values) and center 4 has completely missing data for week 44 measurements. The majority of infants (n = 630) are from center 2.

```{r}
#summarize missingness by row
pct_na_r <- round(rowSums(is.na(trach_data)) / ncol(trach_data) * 100,2)
row_na <- data.frame(patient_id = trach_data$record_id, pct_na = pct_na_r, Center = trach_data$center, Trach = trach_data$Trach)

row_na <- row_na[row_na$pct_na > 30,]  # participants w/ greater than % missing
df <- row_na %>% group_by(Center, Trach) %>% summarize(Median = round(mean(pct_na),2), SD = round(sd(pct_na),2), n = n()) 

Tab2<- kable(df, caption = "Summary of missing data by infants",
      col.names = c("Center", "Trach", "Mean Percentage", "Std. Dev.","n")) %>% 
  kable_styling(latex_options = c("striped"), stripe_color = "gray!15", full_width = F)
Tab2

```

```{r}
#create summary table overall by trach
subset <- trach_data %>% select(!c("record_id"))
names(subset) <- c("center", "Maternal Race", "Maternal Ethnicity", "Birth weight (g)","Gestational Age", "Birth Length (cm)", "birth_hc", "del_method",      "prenat_ster", "com_prenat_ster" , "mat_chorio", "Gender", "sga", "any_surf",   "weight_today.36", "ventilation_support_level.36","inspired_oxygen.36","p_delta.36","peep_cm_h2o_modified.36", "med_ph.36", "weight_today.44", "ventilation_support_level_modified.44", "inspired_oxygen.44" , "p_delta.44" ,   "peep_cm_h2o_modified.44" ,"med_ph.44","hosp_dc_ga" ,"Trach", "Death" , "severity.36")

vars <- c("center", "Maternal Race", "Maternal Ethnicity", "Birth weight (g)","Gestational Age", "Birth Length (cm)", "birth_hc", "del_method","prenat_ster", "com_prenat_ster" , "mat_chorio", "Gender", "sga", "any_surf", "weight_today.36", "ventilation_support_level.36",  "inspired_oxygen.36","p_delta.36",            "peep_cm_h2o_modified.36", "med_ph.36", "weight_today.44", "ventilation_support_level_modified.44", "inspired_oxygen.44" , "p_delta.44" , "peep_cm_h2o_modified.44" ,"med_ph.44","hosp_dc_ga" ,"Trach","Death","severity.36")

#subset$center <- as.numeric(subset$center)
#subset <- subset %>% filter(center != 10)
tab3 <- CreateTableOne(data = subset, vars = vars, strata = "Trach", addOverall = T)
names(tab3$ContTable) <- c("Overall", "No Trach", "Trach")
names(tab3$CatTable) <- c("Overall", "No Trach", "Trach")
Tab3 <-  kableone(tab3 , caption = "Population Characteristics Stratified by Tracheostomy Outcome",  format = 'latex',booktabs=TRUE) %>% kable_styling(latex_options = c("scale_down"), full_width = F)
Tab3
#table for categorical outcomes
# names(tab1$CatTable) <- c("No Trach", "Trach")
# print(tab1$CatTable) %>%
#  kbl(caption = "Population Characteristics Stratified by Tracheostomy Outcome") %>%
#  kable_paper("hover", full_width = F) 
```

```{r}
#create summary table stratified by center
#subset <- trach_data %>% select(!c("record_id"))
#subset$center <- as.numeric(subset$center)
subset <- subset %>% filter(center != "21")
subset$center <- factor(subset$center )
#levels(subset$center)

vars = c("Maternal Race", "Meternal Ethnicity" , "Birth weight (g)", "Gestational Age", "Birth Length (cm)", "birth_hc" ,   "del_method" ,"prenat_ster",  "com_prenat_ster"                      
, "mat_chorio", "Gender","sga",  "any_surf", "weight_today.36",  "ventilation_support_level.36" ,"inspired_oxygen.36",  "p_delta.36", "peep_cm_h2o_modified.36", "med_ph.36", "weight_today.44",  "ventilation_support_level_modified.44"
, "inspired_oxygen.44",  "p_delta.44","peep_cm_h2o_modified.44", "med_ph.44","hosp_dc_ga","Trach","Death","severity.36" )

Tab4 <- CreateTableOne(data = subset, vars = vars, strata = c("center"))
#kableone(tab3)

outfinish4 <- kableone(Tab4 , format = 'latex',  align = 'c' , booktabs=TRUE, caption = "Population Characterstics Stratified by Center") %>% 
 kable_styling(latex_options = c("scale_down"))

outfinish4
```

## Model derivation, validation, selection

All statistical analyses were performed using R Version 4.3.1. Using the mice package in R, 5 imputed train and test datasets were generated with a 70-30 train-test split. The models were fit on the training data and validated on the test data. A total of 7 models were developed from the 30 available predictor variables to predict whether an infant will undergo a tracheostomy. Model 1 included only main interactions and was derived and cross-validated using a ridge model selection procedure. Model 2 was allowed to include potential two-way interactions and Model 3 included only main interactions. Both Model 2 and 3 were derived and cross-validated through a lasso variable selection procedure. The glmnet package in R was used to fit both ridge and lasso models. Lastly, models 4 and 5, were fit and allowed to include only one-way terms, with model 4 following a forward stepwise and model 5 following a backward stepwise model selection procedure.

## Results

```{r}
###########
#impute data: train and test
###########

#Apply selected models to a train test
set.seed(22112)
ignore <- sample(c(TRUE, FALSE), size = nrow(trach_data), replace = TRUE, prob = c(0.3, 0.7))

# scenario 2: train and test in separate datasets
#trach_data <- as.numeric(trach_data$record_id)
trach_data <- trach_data[,-31] #remove severity var
traindata <- trach_data[!ignore, ]
testdata <- trach_data[ignore, ]
imp.train <- mice(traindata, m = 5, maxit = 5, print = FALSE, seed = 22112)
imp.test2 <- mice.mids(imp.train, newdata = testdata, print = F)

trainingdata <- list()
validationdata <- list()

for(i in 1:5)
{
  trainingdata[[i]] <- complete(imp.train, i)
  
  #code severity variable
  trainingdata[[i]] <- trainingdata[[i]] %>% mutate(severity.36 = case_when(
   (ventilation_support_level.36 == 0 |
      (ventilation_support_level.36 == 1  & inspired_oxygen.36 < 0.22)) ~ 'mild',
   ((ventilation_support_level.36 == 2 & inspired_oxygen.36 <= 0.21) |
      (ventilation_support_level.36 == 1 & inspired_oxygen.36 < 0.30 & inspired_oxygen.36 >= 0.22)) ~ 'moderate',
    ((ventilation_support_level.36 == 2 & inspired_oxygen.36 > 0.21) |
       (ventilation_support_level.36 == 1 & inspired_oxygen.36 >= 0.30)) ~ 'severe'))
  trainingdata[[i]]$severity.36 <- as.factor(trainingdata[[i]]$severity.36)
  
  testdata[[i]] <- complete(imp.test2, i)
  
  #code severity variable
  testdata[[i]] <- testdata[[i]] %>% mutate(severity.36 = case_when(
   (ventilation_support_level.36 == 0 |
      (ventilation_support_level.36 == 1  & inspired_oxygen.36 < 0.22)) ~ 'mild',
   ((ventilation_support_level.36 == 2 & inspired_oxygen.36 <= 0.21) |
      (ventilation_support_level.36 == 1 & inspired_oxygen.36 < 0.30 & inspired_oxygen.36 >= 0.22)) ~ 'moderate',
    ((ventilation_support_level.36 == 2 & inspired_oxygen.36 > 0.21) |
       (ventilation_support_level.36 == 1 & inspired_oxygen.36 >= 0.30)) ~ 'severe'))
 testdata[[i]]$severity.36 <- as.factor(testdata[[i]]$severity.36)
  
}



#which(is.na(trainingdata[[1]]$severity.36))
#sum(is.na(testdata[[1]]$severity.36))

```

```{r}
#########
# LASSO
#########

fit_lasso <- function(train) { 
  #' Runs 10-fold CV for lasso and returns corresponding coefficients 
  #' @param df, data set
  #' @return coef, coefficients for minimum cv error
  
  #grid range for lambda
  grid <- 10^ seq (10 , -2, length = 100)
  train <- train[,c(-30)] #remove death
  train <- train[,c(-1)] #remove id
  
  # Matrix form for ordered variables
  #including two-way interactions
  x.ord2 <- model.matrix(Trach~.^2, data = train)[,-c(29)] #remove trach 
  #only single terms
  x.ord <- model.matrix(Trach~., data = train)[,-c(29)] 
  y.ord <- train$Trach
    
  # Generate folds
  k <- 10 
  set.seed(1) # consistent seeds between imputed data sets
  folds <- sample(1:k, nrow(train), replace=TRUE)
  
  # Lasso model without interactions
  lasso_mod_cv <- cv.glmnet(x.ord, y.ord, nfolds = 10, foldid = folds, alpha = 1, lambda = grid, family = "binomial") 
  bestlam <- lasso_mod_cv$lambda.min
  lasso_mod1 <- glmnet(x.ord, y.ord, nfolds = 10, foldid = folds,alpha = 1, lambda = bestlam, family = "binomial")
  
  # Lasso model with interactions
  lasso_mod_cv2 <- cv.glmnet(x.ord2, y.ord, nfolds = 10, foldid = folds, alpha = 1, lambda = grid, family = "binomial") 
  
  bestlam2 <- lasso_mod_cv2$lambda.min
  
  lasso_mod2 <- glmnet(x.ord2, y.ord, nfolds = 10, foldid = folds,  alpha = 1, lambda = bestlam2, family = "binomial")
  
  # Get coefficients 
  coef1 <- coef(lasso_mod1)
  coef2 <- coef(lasso_mod2) 
  #coef <- list(coef1,coef2)
  
  #return best model
  lasso_models <- list()
  lasso_models <- list(coef1, coef2, lasso_mod1, lasso_mod2)
   
  return(lasso_models) 
} 

# Find average lasso coefficients over imputed datasets
lasso_coef1 <-  fit_lasso(trainingdata[[1]]) 
lasso_coef2 <-  fit_lasso(trainingdata[[2]])
lasso_coef3 <-  fit_lasso(trainingdata[[3]]) 
lasso_coef4 <-  fit_lasso(trainingdata[[4]])
lasso_coef5 <-  fit_lasso(trainingdata[[5]])

lasso_coef_all_1 <- cbind(lasso_coef1[[1]], lasso_coef2[[1]], lasso_coef3[[1]],lasso_coef4[[1]], lasso_coef5[[1]]) 

lasso_coef_all_2 <- cbind(lasso_coef1[[2]], lasso_coef2[[2]], lasso_coef3[[2]],lasso_coef4[[2]], lasso_coef5[[2]]) 

#for the model with  main interactions
avg_coefs_lasso1 <- apply(lasso_coef_all_1, 1, mean)
var_coefs_lasso1 <- apply(lasso_coef_all_1, 1, var)
#for the model with two-way interactions
avg_coefs_lasso2 <- apply(lasso_coef_all_2, 1, mean)
var_coefs_lasso2 <- apply(lasso_coef_all_2, 1, var)
 
# Find predicted probabilities on long imputed test data (no rounding applied in this case!)
trach_df_long <- complete(imp.test2,action="long")
subset_long <- trach_df_long[,-c(1,2,3,32)]
subset_long <- subset_long %>% mutate(severity.36 = case_when(
   (ventilation_support_level.36 == 0 |
      (ventilation_support_level.36 == 1  & inspired_oxygen.36 < 0.22)) ~ 'mild',
   ((ventilation_support_level.36 == 2 & inspired_oxygen.36 <= 0.21) |
      (ventilation_support_level.36 == 1 & inspired_oxygen.36 < 0.30 & inspired_oxygen.36 >= 0.22)) ~ 'moderate',
    ((ventilation_support_level.36 == 2 & inspired_oxygen.36 > 0.21) |
       (ventilation_support_level.36 == 1 & inspired_oxygen.36 >= 0.30)) ~ 'severe'))

subset_long$severity.36 <- as.factor(subset_long$severity)

#for one way interactions
x_vars <- model.matrix(Trach~. , subset_long)
subset_long$score_lasso1 <- x_vars %*% (avg_coefs_lasso1)
mod_lasso1 <- glm(Trach~score_lasso1, data = subset_long, family = "binomial")
predict_probs_lasso1 <- predict(mod_lasso1, type="response")

#for two way interactions
x_vars2 <- model.matrix(Trach~(.)^2 , subset_long[,-30])
subset_long$score_lasso2 <- x_vars2 %*% (avg_coefs_lasso2)
mod_lasso2 <- glm(Trach~score_lasso2, data = subset_long, family = "binomial")
predict_probs_lasso2 <- predict(mod_lasso2, type="response")


#Discrimination - ROC and AUC
roc_mod_lasso1 <- roc(predictor=predict_probs_lasso1, 
                response=as.factor(mod_lasso1$y), levels = c(0,1), direction = "<")
plot(main = "Lasso Model One-Way", roc_mod_lasso1, print.auc = T, print.thres = T)
roc_mod_lasso2  <- roc(predictor=predict_probs_lasso2, 
                response=as.factor(mod_lasso2$y))
plot(main = "Lasso Model Two-Way", roc_mod_lasso2, print.auc = T, print.thres = T)

roc_vals_lasso1 <- coords(roc=roc_mod_lasso1, x = "best")
roc_vals_lasso2 <- coords(roc=roc_mod_lasso2, x = "best")


#comparison of values
get_vals <- function(pred_probs, thresh, y)
{
pred_ys <- ifelse(pred_probs > thresh, 1, 0)
pred_ys <- factor(pred_ys, levels = c("0", "1"))
tab_outcome <- table(mod_lasso1$y, pred_ys)
tab_outcome
#sens <- tab_outcome[2,2]/(tab_outcome[2,1]+tab_outcome[2,2])
#spec <- tab_outcome[1,1]/(tab_outcome[1,1]+tab_outcome[1,2])
ppv <- tab_outcome[2,2]/(tab_outcome[1,2]+tab_outcome[2,2])
npv <- tab_outcome[1,1]/(tab_outcome[1,1]+tab_outcome[2,1])
acc <- (tab_outcome[1,1]+tab_outcome[2,2])/sum(tab_outcome)
vals <- data.frame(Measures = c("PPV", "NPV", "Acc"),
           Values = round(c(ppv, npv, acc),3))

return(vals)
}


vals_lasso1 <- get_vals(predict_probs_lasso1,roc_vals_lasso1$threshold,mod_lasso1$y)
vals_lasso2 <- get_vals(predict_probs_lasso2,roc_vals_lasso2$threshold,mod_lasso2$y)

```

```{r}

fit_ridge <- function(train)
{
  #' Runs 10-fold CV for ridge and returns corresponding coefficients 
  #' @param df, data set
  #' @return coef, coefficients for minimum cv error
  
  #grid range for lambda
  grid <- 10^ seq (10 , -2, length = 100)
  train <- train[,c(-30)] #remove death
  train <- train[,c(-1)] #remove id
  
  # Matrix form for ordered variables
  #only single terms
  x.ord <- model.matrix(Trach~., data = train)[,-c(29)] 
  y.ord <- train$Trach
    
  # Generate folds
  k <- 10 
  set.seed(1) # consistent seeds between imputed data sets
  folds <- sample(1:k, nrow(train), replace=TRUE)
  
  # Lasso model without interactions
  ridge_mod_cv <- cv.glmnet(x.ord, y.ord, nfolds = 10, foldid = folds, 
                         alpha = 0, lambda = grid, family = "binomial") 
  bestlam <- ridge_mod_cv$lambda.min
  
  ridge_mod <- glmnet(x.ord, y.ord, nfolds = 10, foldid = folds, 
                         alpha = 0, lambda = bestlam, family = "binomial")
  
  # Get coefficients 
  coef <- coef(ridge_mod) 
  
  dat <- list(ridge_mod, coef)
  return(dat) 
}


# Find average lasso coefficients over imputed datasets
ridge_coef1 <-  fit_ridge(trainingdata[[1]]) 
ridge_coef2 <-  fit_ridge(trainingdata[[2]])
ridge_coef3 <-  fit_ridge(trainingdata[[3]]) 
ridge_coef4 <-  fit_ridge(trainingdata[[4]])
ridge_coef5 <-  fit_ridge(trainingdata[[5]])

ridge_coef <- cbind(ridge_coef1[[2]], ridge_coef2[[2]], ridge_coef3[[2]],ridge_coef4[[2]],ridge_coef5[[2]]) 

#for the model with  main interactions
avg_coefs_ridge <- apply(ridge_coef, 1, mean)
var_coefs_ridge <- apply(ridge_coef, 1, var)

#for one way interactions
x_vars <- model.matrix(Trach~. , subset_long[,-c(30,31)])
subset_long$score_ridge <- x_vars %*% (avg_coefs_ridge)
mod_ridge <- glm(Trach~score_ridge, data = subset_long, family = "binomial")
predict_probs_ridge <- predict(mod_ridge, type="response")

#Discrimination - ROC and AUC
roc_mod_ridge <- roc(predictor=predict_probs_ridge, 
                response=as.factor(mod_ridge$y))
plot(main = "Ridge Model",roc_mod_ridge, print.auc = T, print.thres = T)

roc_vals_ridge <- coords(roc=roc_mod_ridge, x = "best")

#comparison of values
vals_ridge <- get_vals(predict_probs_ridge,roc_vals_ridge$threshold, mod_ridge$y)
```

```{r}
logistic <- function(train)
 {
   #' Fits logistic model and returns corresponding coefficients 
   #' @param df, data set
   #' @return coef, model coefficients

  train <- train[,c(-30)] #remove death
  train <- train[,c(-1)] #remove id

   # Matrix form for ordered variables
  #including two-way interactions
  x.ord2 <- model.matrix(Trach~.^2, data = train)[,-c(29)] #remove trach
  #only single terms
  x.ord <- model.matrix(Trach~., data = train)[,-c(29)]
  y.ord <- train$Trach

  log_modfull <- glm(y.ord ~ x.ord, family = "binomial")
   log_modnull <- glm(y.ord ~ 1, family = "binomial")

forwardstep <- step(log_modnull, scope = formula(log_modfull), direction='forward', trace = 0)
coef <- coef(forwardstep)
#for one way interactions
#predict_probs_fwdstep <- predict(forwardstep, type="response", newdata = subset_long)

dat <- list(coef, forwardstep)
return(dat)

}

logistic1 <- logistic(trainingdata[[1]]) 
logistic2 <- logistic(trainingdata[[2]]) 
logistic3 <- logistic(trainingdata[[3]]) 
logistic4 <- logistic(trainingdata[[4]]) 
logistic5 <- logistic(trainingdata[[5]])
 
logistic_coef <- cbind(logistic1[[1]], logistic2[[1]], logistic3[[1]],logistic4[[1]],logistic5[[1]]) 
 
#' logistic_coef[is.na(logistic_coef)] <- 0
#for the model with  main interactions
avg_coefs_forward <- apply(logistic_coef, 1, mean)
var_coefs_forward <- apply(logistic_coef, 1, var)

#for one way interactions
x_vars <- model.matrix(Trach~. , subset_long[,-c(33,32,31,30)])
x_vars[2] <- 0 
avg_coefs_forward[2] <- 0
subset_long$score_fwd1 <- x_vars %*% (avg_coefs_forward)
mod_logistic_fwd1 <- glm(Trach~score_fwd1, data = subset_long, family = "binomial")
predict_probs_fwd1 <- predict(mod_logistic_fwd1, type="response")


roc_mod_forward  <- roc(predictor=predict_probs_fwd1, 
                response=as.factor(mod_logistic_fwd1$y))
plot(main = "Forward Model", roc_mod_forward, print.auc = T, print.thres = T)
roc_vals_forward <- coords(roc=roc_mod_forward, x = "best")

#comparison of values
vals_forward <- get_vals(predict_probs_fwd1,roc_vals_forward$threshold, mod_logistic_fwd1$y)
```

```{r}
logistic_backward <- function(train)
 {
   #' Fits logistic model and returns corresponding coefficients 
   #' @param df, data set
   #' @return coef, model coefficients

  train <- train[,c(-30)] #remove death
  train <- train[,c(-1)] #remove id

   # Matrix form for ordered variables
  #including two-way interactions
  x.ord2 <- model.matrix(Trach~.^2, data = train)[,-c(29)] #remove trach
  #only single terms
  x.ord <- model.matrix(Trach~., data = train)[,-c(29)]
  y.ord <- train$Trach

  log_modfull <- glm(y.ord ~ x.ord, family = "binomial")
   log_modnull <- glm(y.ord ~ 1, family = "binomial")

backwardstep <- step(log_modfull, scope = formula(log_modnull), direction='backward', trace = 0)
coef <- coef(backwardstep)
#for one way interactions
#predict_probs_fwdstep <- predict(forwardstep, type="response", newdata = subset_long)

dat <- list(coef, backwardstep)
return(dat)

}

logisticb1 <- logistic_backward(trainingdata[[1]]) 
logisticb2 <- logistic_backward(trainingdata[[2]]) 
logisticb3 <- logistic_backward(trainingdata[[3]]) 
logisticb4 <- logistic_backward(trainingdata[[4]]) 
logisticb5 <- logistic_backward(trainingdata[[5]])
 
logistic_b_coef <- cbind(logisticb1[[1]], logisticb2[[1]], logisticb3[[1]],logisticb4[[1]],logisticb5[[1]]) 
 
#' logistic_coef[is.na(logistic_coef)] <- 0
#for the model with  main interactions
avg_coefs_backward <- apply(logistic_b_coef, 1, mean)
var_coefs_backward <- apply(logistic_b_coef, 1, var)

#for one way interactions
x_vars <- model.matrix(Trach~. , subset_long[,-c(33,32,31,30)])
x_vars[2] <- 0 
avg_coefs_backward[2] <- 0
subset_long$score_bwd <- x_vars %*% (avg_coefs_backward)
mod_logistic_bwd <- glm(Trach~score_bwd, data = subset_long, family = "binomial")
predict_probs_bwd <- predict(mod_logistic_bwd, type="response")

#Discrimination - ROC and AUC
roc_mod_backward <- roc(predictor=predict_probs_bwd, 
                response=as.factor(mod_logistic_bwd$y), levels = c(0,1), direction = "<")
plot(main = "Backward Model",roc_mod_backward, print.auc = T, print.thres = T)
roc_vals_backward <- coords(roc=roc_mod_backward, x = "best")

#comparison of values
vals_backward<- get_vals(predict_probs_bwd,roc_vals_backward$threshold, mod_logistic_bwd$y)

```

```{r}

#Table of coefficients 

lass1 <- avg_coefs_lasso1  #[avg_coefs_lasso1 != 0.00]
lass2 <- avg_coefs_lasso2[avg_coefs_lasso2 != 0.00]
ridge <- avg_coefs_ridge
fwd <- avg_coefs_forward
bwd <- avg_coefs_backward

coef_df <- cbind(lass01 = round(lass1,4),lass02 = round(lass2,4), Ridge = round(ridge,4), Forward = round(fwd,4), Backward = round(bwd,4))

df <- as.data.frame(coef_df)

df2 <- df %>%
  summarise_all(~sum(. == 0))

Tab10 <- df2 %>%
  knitr::kable(col.names = c("Lasso", "Lasso2", "R", "F", "B"), booktabs = T, caption = "Zero Coefficients for Models") %>%
   kable_styling(latex_options = c("striped"),full_width = F)
Tab10


#closeness of values
threshold = 0.02

close_counts <- combn(names(df), 2, function(cols) {
  sum(abs(df[[cols[1]]] - df[[cols[2]]]) < threshold)
}, simplify = TRUE)

# Summarize the total count of close values for each pair of columns
summary_result <- data.frame(
  Column_Pair = combn(names(df), 2, paste, collapse = "_vs_"),
  Close_Count = close_counts
)
Tab8 <- summary_result %>% kable(col.names = c("Column Pair", "Close Count"), booktabs = T, caption = "Close Coefficients") %>% kable_styling(latex_options = c("striped"),full_width = F)
Tab8

# data <- as.data.frame(data)
# new <- cbind(df,data[,6])

#Tab7 <- new %>%
#  knitr::kable(col.names = c("Lasso", "Lasso2", "R", "F", "B", "Close Count"), booktabs = T, caption = "Coefficients for Models") %>%
#   kable_styling(latex_options = c("scale_down"),full_width = F)

#Tab7

```

```{r}
#Tables for model comparison
values <- cbind(Measure = c("PPV", "NPV", "Acc"), Lasso = vals_lasso1[,2], Lasso_int= vals_lasso2[,2], Ridge = vals_ridge[,2], Forward = vals_forward[,2],
                Backward = vals_backward[,2])

tab4 <- as.data.frame(values)


Tab4 <- kable(tab4, caption = "Metrics by Model", col.names = c("Measure",  "Lasso one-way interactions only", "Lasso two-way interactions", "Ridge", "Forward", "Backward")) %>%
  kable_styling(latex_options = c("striped"),full_width = F)
Tab4


tab <- rbind(roc_vals_lasso1, roc_vals_lasso2, roc_vals_ridge, roc_vals_forward, roc_vals_backward)
Models <- c("Lasso one-way interactions only", "Lasso two-way interactions","Ridge","Forward", "Backward")



tab5 <- cbind(Models, tab)

Tab5 <- kable(tab5, caption = "Metrics by Model", col.names = c("Models", "Threshold","Specificity", "Sensitivity" )) %>%
   kable_styling(latex_options = c("striped"),full_width = F)
 Tab5


```

## 

## Discussion

Table 7 summarizes the positive predictive values, negative predictive values, and accuracy measure for each fitted model. As expected, the ridge model performed the worse out of all models, with the lowest PPV value of 0.159. Despite the addition of two-way interaction terms, the lasso with only one-way terms performed similar to the lasso two-way interaction in terms of negative predictive values. However the lasso with two-way interactions performed better in terms of overall accuracy, having an accuracy of 0.35. The ridge, forward and backward performed similarly in overall accuracy.

Table 8 summarizes the ROC curves plotted above. The lasso two-way had the highest sensitivity and specificity out of all the models. Ridge, forward, and backward performed similarly, with slight tradeoffs between ridge and forward/backward for specificity and sensitivity. The optimal threshold selected for the two-way lasso is 0.115, a lower threshold compared to all other models. The final model selected from examining the overall performance is the two-way lasso model.

In Tables 5, we observe that the lasso two-way model shrunk 17 coefficients towards zero. In contrast, the ridge, forward, and backward only had four zero coefficients. Having more nonzero coefficients within the model most likely affected the accuracy of the ridge, forward, and backwards models when being applied to the test data. In Table 6, we compare the closeness of the predicted coefficients for between each model. As expected, forward and backward had the closets number of coefficient estimates due to the zero estimated coefficients which were seen in the two-way models but not in the one-way models. Ridge had 31 similar coefficient estimates to forward and backward. Lasso two-way had the least similar estimated coefficients to all other models. This difference in the lasso two-way's coefficient estimates led to the differences in model performance observed.

### Limitations

A major limitation of this study is due to the amount of missing data. Using multiple imputation, with a predictive mean method, a large portion of the data for 44 weeks measures was imputed, thus creating assumptions for what the data looks like at these time points. Additionally, the data provided included indicator for whether an infant died. This was not taken into consideration in this model derivation since the cause of death was not specified. The outcome of death may be due to non-tracheostomy related comorbidity. In having such information, a composite score of death and tracheostomy would be better suited. Lastly, the models were fit to predict tracheostomy outcome, but the time at which it occurs is not specified. These models assume that the infant is alive at 36 and 44 week time points as the models incorporate these data measures.

\newpage

### Code Appendix

```{r get-labels, echo = FALSE}
labs = knitr::all_labels()
labs = setdiff(labs, c("setup","get-labels"))
```

```{r ref.label=knitr::all_labels (), echo=TRUE, eval=FALSE}

```
